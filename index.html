<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="author" content="John Doe">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/GodBian/favicon.png" rel="icon">
  <link rel="alternate" href="/GodBian/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/GodBian/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/GodBian/">Hexo</a></h1>
  <h2><a href="/GodBian/"></a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/GodBian/2020/06/01/UnityShader 从入门到盖棺(三)/">UnityShader 从入门到盖棺(三)</a></h1>
  

      
        <time datetime="2020-06-01T15:00:15.223Z">2020-06-01</time>
      
    </header>
    <div class="entry">
      
        <p><img src="https://img-blog.csdnimg.cn/20200601224649614.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="gta5_car"></p>
<h3 id="Phong和Blinn模型"><a href="#Phong和Blinn模型" class="headerlink" title="Phong和Blinn模型"></a>Phong和Blinn模型</h3><p>上一篇我们讲到了Lambert模型，这次我们讲一下Phong和Blinn光照模型。这两种模型都是基于Lambert模型加入了高光部分。</p>
<p>接下来的实现，我们用于完善我们上次房子场景的周边环境。这是我上次构建完房子场景后的一个大胆想法，就是把所有知识点放在我们的房子场景上，然后大家看到场景的一部分可能就能想起某个点(→_→)。</p>
<p>来，老规矩，上结果图。</p>
<p><img src="https://img-blog.csdnimg.cn/20200601223856392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="sc1"></p>
<p>我们先来实现phong光照模型。实现之前，我们在场景中摆两个球，然后创建一个新的材质，名为3_BallPhong。材质的Shader先选择上一篇的2_WallDiffuse。然后贴图使用Textures/3_MetalDiffuse。然后我们就可以看到结果如下</p>
<p><img src="https://img-blog.csdnimg.cn/20200601223803983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="dc1"></p>
<p><img src="https://img-blog.csdnimg.cn/20200601223749566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="dc2"></p>
<p>这是上一篇的效果，只应用了漫反射光。下面我们开始加入phong模型中的高光，所谓的高光其实是光照照射到表面的镜面反射部分，就跟镜子反射光照一样的。所以我们需要算出光照通过表面直接反射到人眼的部分，只需要算出光反射向量和视线向量的夹角即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20200601223848590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="math"></p>
<p>创建Shader文件3_CopperPhong.shader, 然后把上一篇的2_WallDiffuse.shader的内容全部复制过来。把片段着色器代码修改成下面的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">	float3 worldNormal &#x3D; normalize(i.worldNormal);</span><br><span class="line">	float3 worldLightDir &#x3D; normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">	fixed4 albedo &#x3D; tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">	fixed3 ambient &#x3D; UNITY_LIGHTMODEL_AMBIENT * albedo.rgb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    float lambert &#x3D; saturate(dot(worldNormal, worldLightDir));</span><br><span class="line">    fixed3 diffuse &#x3D; _LightColor0.rgb * albedo.rgb  * lambert;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; phong高光部分</span><br><span class="line">    &#x2F;&#x2F; 算出光照和表面的反射向量，Unity提供内置函数reflect帮我们完成。</span><br><span class="line">    float3 worldRefelctDir &#x3D; normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">    float3 worldViewDir &#x3D; normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">    &#x2F;&#x2F; 用反射向量和视线向量的夹角模拟高光的影响程度</span><br><span class="line">    float spec &#x3D; saturate(dot(worldRefelctDir, worldViewDir));</span><br><span class="line">    fixed3 specular &#x3D; _LightColor0.rgb * _SpecularColor.rgb * spec;</span><br><span class="line"></span><br><span class="line">	return fixed4(ambient + diffuse + specular, albedo.a); &#x2F;&#x2F; 输出物体主颜色</span><br></pre></td></tr></table></figure>

<p>然后我们把一开始创建的3_BallPhong.mat材质的Shader改成我们新写的这个Shader，注意这里用到了一个_SpecularColor变量，他是一个颜色变量，是作为输入参数传进来的。读者应该记得怎么添加一个输入颜色变量吧，不记得的可以去看看源码的Properties属性块复习一下，这个变量声明的代码我没有贴出来的。我们在属性面板把这个颜色调整为金属球的颜色。</p>
<p><img src="https://img-blog.csdnimg.cn/20200601223837429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="pickcolor"></p>
<p>然后效果图如下</p>
<p><img src="https://img-blog.csdnimg.cn/20200601223817178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="fc1"></p>
<p>大家可以看到，加入高光后铜球的一部分的确很亮。但是现实生活中金属球的高光好像范围没有那么大。事实上，上面的高光系数计算漏了phong光照模型里很重要的一步(我自己做的时候漏了 - -)。那就是对高光系数做一个幂次方，让高光范围变窄，因为现实中，金属高光只有直接反射到人眼的最明显，然后随着角度变大，衰减很快。因此我们再定义一个输入变量_Shiness（这是一个RANGE变量，代表用户可以在一个范围内选取某个值）来完善高光系数的计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在属性块中定义_Shiness变量</span><br><span class="line">_Shiness (&quot;shiness&quot;, RANGE(8.0, 64.0)) &#x3D; 8.0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在CGPROGRAM-ENDCG代码中声明_Shiness变量</span><br><span class="line">float _Shiness;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改Spec系数的计算</span><br><span class="line">float spec &#x3D; pow(saturate(dot(worldRefelctDir, worldViewDir)), _Shiness);</span><br></pre></td></tr></table></figure>

<p>修改代码后的结果图如下，读者可以自己调整_Shiness查看效果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200601223830457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="fc2"></p>
<p>理论上，向光面的高光分量可以无限趋向于0，但不应该为0。但是phong光照模型在反射光照和视线夹角大于90度时，是会被截断为0的。在某些情况下，这样的截断会导致高光区域出现明显的断层。可以参考<a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/01%20Advanced%20Lighting/" target="_blank" rel="noopener">LearnOpengl</a>上的效果图</p>
<p>接下来我们实现Blinn光照模型。Blinn光照模型在Phong光照模型上做了一点修改。提出了半程向量，即光照法向和视线方向的中间向量。然后用这个半程向量和法线进行点乘来算高光系数。读者会发现，用这样的计算方法，向光面的高光系数就不会小于0。</p>
<p>创建一个新的Shader文件，命名为3_CopperBlinn.shader。把3_CopperPhong的代码复制到这里。然后修改spec系数部分为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; blinn高光部分</span><br><span class="line">float3 worldViewDir &#x3D; normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">&#x2F;&#x2F; 算出半程向量</span><br><span class="line">float3 halfDir &#x3D; normalize(worldLightDir + worldViewDir);</span><br><span class="line">&#x2F;&#x2F; 用反射向量和视线向量的夹角模拟高光的影响程度</span><br><span class="line">float spec &#x3D; pow(saturate(dot(worldNormal, halfDir)), _Shiness);</span><br><span class="line">fixed3 specular &#x3D; _LightColor0.rgb *_SpecularColor.rgb * spec;</span><br></pre></td></tr></table></figure>

<p>新建一个材质，应用3_CopperBlinn.shader，把这个材质应用到右边的球体，然后把shiness系数调到32(shiness系数相同下，blinn光照的高光范围比phong光照要大，读者可以想想原因)。效果图如下</p>
<p><img src="https://img-blog.csdnimg.cn/20200601223734422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="bc1"></p>
<p>好了，以上就是phong光照模型和blinn光照模型。这两个模型没有绝对的正确与否，大家都是经验模型。实际用哪个需要在不同的情况下考虑。最后我们再看下最终场景图，大家可以对比一下一开始的lambert模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20200601223856392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="sc1"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>第三篇的分享结束了，有疑问就留言，之后的源码会越来越少，发现不对劲可以到Github上看源码。</p>
<p>但不管怎样，支持作者环节必不可缺。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517160234929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="vxpay"></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>github地址：<a href="https://github.com/gjbian/Unity-Shader-Study" target="_blank" rel="noopener">https://github.com/gjbian/Unity-Shader-Study</a></p>
<p>上一篇：<a href="https://blog.csdn.net/qa1041335855/article/details/106318380" target="_blank" rel="noopener">UnityShader 从入门到盖棺(二)</a></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/GodBian/2020/05/24/UnityShader 从入门到盖棺(二)/">UnityShader 从入门到盖棺(二)</a></h1>
  

      
        <time datetime="2020-05-24T10:58:50.076Z">2020-05-24</time>
      
    </header>
    <div class="entry">
      
        <p><img src="https://img-blog.csdnimg.cn/20200524180830330.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="gamebighouse"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;这是我入门学习笔记的第二篇。这篇开始，我们会逐渐做一些更贴近实际的效果。而不是和上周那个球体球体，随便输出点莫名其妙，妙不可言的颜色(✿◕‿◕✿)。</p>
<p>&emsp;另外，本章节可能还会稍微提及上一章的代码，但是后续可能会逐渐跳过大量的代码来篇幅。毕竟我想让读者关注到本章更核心的内容，而不是一直重复某些事情。如果读者想要获取完整代码甚至整个场景，可以到我的<a href="https://github.com/gjbian/Unity-Shader-Study" target="_blank" rel="noopener">github</a>上面去下载。</p>
<h3 id="贴图和lambert光照模型"><a href="#贴图和lambert光照模型" class="headerlink" title="贴图和lambert光照模型"></a>贴图和lambert光照模型</h3><p>回到正文，如标题说的，本章分享一下贴图，以及一个很简单的光照模型-lambert光照模型。我们还是老套路，先把最终效果砸出来。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175551211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="bighouse"></p>
<p>可以看到，这是一个简单的房子(千万不要和我说丑，说就是一巴掌)。我们第一步，先把房子搭建起来。很简单，只需要创建6个平面。可以参考我的层次关系以及每个平面的变换。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175603985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="modelcreate"></p>
<p>现在每个平面使用的都是默认材质Default-Material。看起来场景样子是这样的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175639179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="tempresult1"></p>
<p>现在我们先不讨论这个默认材质，我们需要创建自己的材质然后替换掉它。</p>
<p>第二步，创建一个Unlit_Shader文件, 命名为2_DiffuseWall。打开UnityShader文件后，把里面的内容全删了，并且复制下面一大段代码进去保存。这里除了Cull Off之外用到的都是上一篇讲到的操作和代码，之后的教程，我会尽量跳过这些内容。</p>
<p>Cull Off, 是指禁用掉面剔除。什么是面剔除，拿一个正方体来说，我们正常能看到的最多是一个正方体的3个面(你可以试下你能不能成为那个不正常的人)，所以剩余三个面就没有绘制的必要了。因此我们会把它剔除掉，具体剔除规则是通过整个面的顶点绘制顺序来判断正反面，我们通常把反面剔除掉。而Plane这个默认对象，他只有单面，因此，如果我们到背面去看他，他就会消失不见，原因就是因为被Unity剔除掉了。禁用之后我们就能看到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shader&#x2F;C2&#x2F;2_WallDiffuse&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainColor (&quot;color tint&quot;, COLOR) &#x3D; (1.0, 1.0, 1.0, 1.0)  &#x2F;&#x2F; 物体的主颜色</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Pass &#123;</span><br><span class="line">		    </span><br><span class="line">		    Cull Off &#x2F;&#x2F; 把面剔除禁用</span><br><span class="line">		    </span><br><span class="line">			CGPROGRAM &#x2F;&#x2F; CG代码块</span><br><span class="line"></span><br><span class="line">			#pragma vertex vert &#x2F;&#x2F; 声明vert函数为顶点着色器</span><br><span class="line">			#pragma fragment frag &#x2F;&#x2F; frag为片段着色器</span><br><span class="line"></span><br><span class="line">			fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">			struct a2v &#123;  &#x2F;&#x2F; 顶点着色器输入结构体</span><br><span class="line">				float4 vertex : POSITION; &#x2F;&#x2F; 顶点物体空间位置</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f &#123;  &#x2F;&#x2F; 片段着色器输入结构体</span><br><span class="line">				float4 pos : SV_POSITION; &#x2F;&#x2F; 顶点裁剪空间位置</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos &#x3D; UnityObjectToClipPos(v.vertex); &#x2F;&#x2F; MVP变换</span><br><span class="line">				return o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				return _MainColor; &#x2F;&#x2F; 输出物体主颜色</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Fallback &quot;Diffuse&quot;  &#x2F;&#x2F; 备胎</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了应用上我们的Unity Shader，我们还得创建一个材质。每个shader和材质都是一一对应的。后面我说创建一个材质，就意味着创建一个和UnityShader同名的材质，并且选中对应的Shader(上一节已经讲过这个操作)。操作完之后，把材质拖到6个plane中，我们可以看到如下效果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175655268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="tempresult2"></p>
<p>可以看到这个效果非常糟糕，纯白色一片，差点亮瞎我家小致的狗眼。我们希望这是一堵砖墙，而不是这样一个白色平面，毫无细节。因此，我准备了一张砖的图片(来自Shader入门精要)，接下来我们把这张图片贴到我们的平面上。</p>
<p>第三步，修改着色器代码，增加一个2D纹理属性，用来传入我们的砖墙纹理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">	_MainColor (&quot;color tint&quot;, COLOR) &#x3D; (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">	&#x2F;&#x2F; 2D就是一个二维纹理变量。</span><br><span class="line">	&#x2F;&#x2F; &quot;white&quot;是纹理的默认值, 表示一张纯白色图片</span><br><span class="line">	_MainTex (&quot;main tex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还需要在CG代码块中再声明一次这个变量，供后续着色器代码使用。你们应该知道声明在哪吧，知道吧，知道吧~。不知道的参考下_MainColor变量，然后回顾下上篇讲到的Shader结构。也可以直接拿github上源码参考。后面的代码不知道放哪我就不重复了哈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; sampler2D是一个二维纹理采样器。</span><br><span class="line">&#x2F;&#x2F; sampler2D就是对应上面的2D属性。</span><br><span class="line">sampler2D _MainTex;</span><br></pre></td></tr></table></figure>

<p>上面提到一个二维纹理采样器。什么是采样器呢。首先采样是指，我们拿到一个片段后，需要一个映射，从一张纹理里面找到这个片段所属的位置，并且把其中的内容读出来。如果这是一张颜色纹理，像我们现在的砖墙，那他的内容对应的就是颜色。相当于我们通过纹理采样过程知道了一个片段的颜色。而辅助我们完成这个采样过程的就是采样器。</p>
<p>二维纹理采样原理也很简单。我们把纹理放在一个二维坐标系里，以左下角为原点(0,0)，右上角为(1,1)。水平轴称为u轴，垂直轴成为v轴。那我们给定一个片段一个坐标(0.5,0.5), 我们就可以把这个坐标映射到纹理的中间。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175616754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="sampler"></p>
<p>来总结一下，上面提到的坐标系就是纹理坐标系，也叫UV坐标系。而(0.5,0.5)这个坐标就是片段的纹理坐标，也叫UV坐标。如果还是有点不太理解的话，可以看看<a href="https://note.youdao.com/" target="_blank" rel="noopener">learnopengl</a>里面更详细的解释。</p>
<p>好了，第四步，我们为了让我们的平面对maintex纹理采样，我们需要给片段着色器输入纹理坐标uv。而这个坐标，Unity会传给我们(模型导入后就会确定下来)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct a2v &#123;</span><br><span class="line">	float4 vertex : POSITION;</span><br><span class="line">	float2 texcoord : TEXCOORD0;  &#x2F;&#x2F; 顶点着色器输入纹理坐标</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line">	float4 pos : SV_POSITION;</span><br><span class="line">	float2 uv : TEXCOORD0; &#x2F;&#x2F; 片段着色器输入纹理坐标</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">	v2f o;</span><br><span class="line">	o.pos &#x3D; UnityObjectToClipPos(v.vertex);</span><br><span class="line">	&#x2F;&#x2F; 我们先直接把Unity给我们的纹理坐标传给片段着色器</span><br><span class="line">	o.uv &#x3D; v.texcoord;</span><br><span class="line">	return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">	fixed4 albedo &#x3D; tex2D(_MainTex, i.uv); &#x2F;&#x2F; 采样</span><br><span class="line">	return albedo; &#x2F;&#x2F; 输出物体主颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面核心代码就是tex2D函数。这个函数第一个参数是纹理采样器，第二个参数是纹理坐标，返回给我们的就是采样结果。</p>
<p>第五步，我们可以看到修改之后的材质里面，我们的纹理属性对应有一个框框。我们把我们的砖墙拖进那个框框里面。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175626617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="selecttex"></p>
<p>可以看到现在场景变成这样！</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175706100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="tempresult3"></p>
<p>是不是瞬间就不一样了。这张颜色纹理为我们补充了大量的细节。如果我们要用纯颜色实现这个，我们需要好多好多个小平面，这就意味更多的人力成本，更多的顶点和更多的运行消耗。</p>
<p>细心的人会发现，我们纹理属性那里除了一个纹理框框，还有4个属性。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175727769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="texst"></p>
<p>这四个属性是用来调节我们纹理坐标的平移缩放的。但是现在大家怎么改都没作用。是因为我们代码里面没用到它，下面我们来完善一下代码。</p>
<p>首先，增加一个变量声明_MainTex_ST。注意，我们不需要在属性块里面填入。我们在属性块声明了一个2D变量后，Unity就会把这个平移缩放赋值给我们在shader代码中声明的纹理名字+_ST的变量。其中S代表缩放，T代表平移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br></pre></td></tr></table></figure>

<p>然后我们在顶点着色器中，把uv的赋值代码修改一下，之前是直接赋值，现在我们加上传入的平移缩放参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o.uv &#x3D; v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">&#x2F;&#x2F; unity的头文件 UnityCG.cginc里面提供了TRANSFORM_TEX函数帮助我们完成这个操作</span><br><span class="line">&#x2F;&#x2F; #include &quot;UnityCG.cginc&quot; &#x2F;&#x2F; 定义在 #pragma的后面</span><br><span class="line">&#x2F;&#x2F; o.uv &#x3D; TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">&#x2F;&#x2F; 之后的代码都会采用这种，因为内置就是香，会帮我们考虑一些跨平台问题</span><br></pre></td></tr></table></figure>

<p>好了，现在回到场景里面，<strong>调整一下4个参数</strong>，看看会发生什么吧！</p>
<p>大家应该发现，尽管我们的场景中有一个光源(默认的平行光，如果你没有，肯定是你多手删掉了)，但是这个光源对我们的房子没有任何影响。理论上，面对光源的墙应该亮一点，而背对光源的墙应该暗一点。</p>
<p>为了实现这个效果，接下来第六步我们简单引入一个光照模型，lambert光照模型。</p>
<p>所谓的光照模型，其实就是一个公式，就是根据这个公式去计算，我们就能获得一个类似光照的效果。这个公式不一定要很正确(现实的光照计算是很复杂的)，只要这个公式能以很高的效率带给我们相对较好的效果，那么就是一个好的光照模型。不同情境下，我们会应用不同的光照模型。</p>
<p>先看看lambert光照模型</p>
<blockquote>
<p>l = ambient + diffuse;</p>
</blockquote>
<p>兰伯特告诉我们，光照里面有环境光和漫反射光两个分量组成。</p>
<p>环境光，大家会发现晚上在一个几乎看不到光源的地方，还是能看清物体，这就是环境光的影响。事实上，环境光是所有光源在多次反射后，在整个环境都留下了它们的踪迹。没错！就是光污染。</p>
<p>漫发射光，就是光线在照射一个物体表面的时候，会向四面八方均匀的反射光线。而这个反射光线的强度和光线照射平面的角度相关。入射光线和法线的夹角越小，反射光线的强度越大。</p>
<p><img src="https://learnopengl-cn.github.io/img/02/02/diffuse_light.png" alt="diffuselight"></p>
<blockquote>
<p>反射光强 = 入射光强 * dot(入射光线， 表面法线)。</p>
</blockquote>
<p>dot是点乘的意思。当入射光线和表面法线都是单位向量(长度为1)的时候，点成就代表他们夹角的余弦值，刚好是我们需要的一个系数。</p>
<p>好了，根据上面简单提到的理论，我们来实现lambert光照模型。首先我们需要一个片段的法线和对应的入射光线方向。这两个属性我们都可以通过unity提供的一些接口或者变量中得到。我们直接看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;UnityCG.cginc&quot;</span><br><span class="line"> &#x2F;&#x2F; 光照相关头文件，可以帮我们计算入射光线</span><br><span class="line">#include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">struct a2v &#123;</span><br><span class="line">	float4 vertex : POSITION;</span><br><span class="line">	float2 texcoord : TEXCOORD0;</span><br><span class="line">	float3 normal : NORMAL;  &#x2F;&#x2F; Unity提供的顶点法线向量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line">	float4 pos : SV_POSITION;</span><br><span class="line">	float2 uv : TEXCOORD0;</span><br><span class="line">	float3 worldPos : TEXCOORD1; &#x2F;&#x2F; 世界空间下的片段位置</span><br><span class="line">	float3 worldNormal : TEXCOORD2; &#x2F;&#x2F; 世界空间下的法线向量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">	v2f o;</span><br><span class="line">	o.pos &#x3D; UnityObjectToClipPos(v.vertex);</span><br><span class="line">	o.uv &#x3D; TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">	o.worldPos &#x3D; mul(UNITY_MATRIX_M, v.vertex.xyz);  &#x2F;&#x2F; 通过模型变换，求出世界空间的顶点位置</span><br><span class="line">	o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal); &#x2F;&#x2F; 求出世界空间的法线位置</span><br><span class="line">	return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">    &#x2F;&#x2F; 把插值结果单位化，注意一定要变成单位向量，否则后面计算会不完整。</span><br><span class="line">	float3 worldNormal &#x3D; normalize(i.worldNormal);</span><br><span class="line">	&#x2F;&#x2F; 通过UnityWorldSpaceLightDir求出光照方向</span><br><span class="line">	float3 worldLightDir &#x3D; normalize(UnityWorldSpaceLightDir(i.worldPos);</span><br><span class="line">	fixed4 albedo &#x3D; tex2D(_MainTex, i.uv);</span><br></pre></td></tr></table></figure>

<p>可以看到上面我们获得了世界空间下的法线向量和光线的入射方向向量。接下来我们开始光照模型的计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 环境光</span><br><span class="line">&#x2F;&#x2F; 内置变量UNITY_LIGHTMODEL_AMBIENT为我们提供了环境光的光强</span><br><span class="line">fixed3 ambient &#x3D; UNITY_LIGHTMODEL_AMBIENT * albedo.rgb;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 漫反射光</span><br><span class="line">&#x2F;&#x2F; saturate可以把输入参数截断到[0,1]区间，相当于 min(0, max(1, x))</span><br><span class="line">float lambert &#x3D; saturate(dot(worldNormal, worldLightDir));</span><br><span class="line">&#x2F;&#x2F; 内置变量_LightColor0为我们提供了光线的颜色</span><br><span class="line">fixed3 diffuse &#x3D; _LightColor0.rgb *albedo.rgb * lambert;</span><br></pre></td></tr></table></figure>

<p>然后我们把得到的两种光照结果应用在lambert光照模型上来计算最终的结果，并作为片段着色器的输出。</p>
<p>这时候我们回到场景看看效果，法线向光面更亮，背光面更暗了！</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175716825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="tempresult4"></p>
<p>最后，我觉得地板用砖好像不太好，所以我多创建了一个材质2_FloorDiffuse, 然后在编辑面板里换了一张水泥贴图。把材质拖到地板上，就是我们的最终效果啦！ヾ(≧▽≦*)o</p>
<p><img src="https://img-blog.csdnimg.cn/20200524175551211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70" alt="bighouse"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>第二篇的分享结束了，不知道你们的是不是有很多问号。我还是强调一下，因为很多理论上的知识我无法展开普及，例如什么是单位向量，什么是点乘。又或者光线颜色和片段颜色相乘的意义是什么等等。</p>
<p>以上这些我都认为大家是知道的，但如果实在有什么地方晦涩难懂或者我说的明显有问题。再或者你真的很萌新，但又很想学好。都可以在评论里面说一下，毕竟我也是基于入门做分享的，希望大家和我都能走到盖棺那一步。</p>
<p>好啦，最核心的支持作者环节来啦！！！</p>
<p><img src="https://img-blog.csdnimg.cn/20200517160234929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="vxpay"></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>github地址：<a href="https://github.com/gjbian/Unity-Shader-Study" target="_blank" rel="noopener">https://github.com/gjbian/Unity-Shader-Study</a></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/GodBian/2020/05/17/UnityShader 从入门到盖棺(一)/">UnityShader 从入门到盖棺(一)</a></h1>
  

      
        <time datetime="2020-05-17T11:40:42.833Z">2020-05-17</time>
      
    </header>
    <div class="entry">
      
        <p><img src="https://img-blog.csdnimg.cn/2020051716051537.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="GTA5"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;笔者我是一个最近在入门UnityShader的菜鸡⊙﹏⊙∥。写点东西巩固自己的认知，顺便看看能不能帮助到其他和我一样想入门的人。</p>
<p>&emsp;&emsp;我是以冯乐乐的《Unity Shader入门精要》来作为我的入门教程的。在接下来的正文里面，我会跳过一些前置知识相关。但这些东西十分重要，所以我会尽量给出一些链接，让大家去了解。我主要是围绕一个个实例，让大家快速做出效果。</p>
<p>&emsp;&emsp;所以如果大家有图形学相关底子，也了解Unity的基础操作，会更方便下面的学习。大家有疑问的，或者我有错误的，欢迎大家评论，一起学习进步。</p>
<p>&emsp;&emsp;另外，我会把整个工程上传到github。大家可以去下载到完整的项目。</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul>
<li>Unity 2019.3.9 (这是我现在使用的版本)</li>
<li>一个编辑器(Rider, Sublime, VS甚至记事本都可以(￣▽￣)”)</li>
</ul>
<h3 id="初识Unity-Shader"><a href="#初识Unity-Shader" class="headerlink" title="初识Unity Shader"></a>初识Unity Shader</h3><p>来到正文了，废话不多说，我们先看一下本节完成后，你会得到一个怎样的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517160306891.png#pic_center" alt="colorSphere1"></p>
<p>好了，让我们打开Unity。</p>
<p>然后在Window-&gt;Rendering-&gt;Lighting Settings打开光照设置，把天空盒关掉。在SkyBox Material那里选择None即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517155748183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="CloseSkyBox"></p>
<p>我们直接创建一个Shaders文件夹，然后在里面新建一个Unity Shader文件(右键-&gt;Create-&gt;Shader-&gt;Unlit Shader)，命名为1_SampleShader。Unlit Shader是一种无关照Shader，它暂时更适合我们入门学习。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517155823100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="CreateShader"></p>
<p>然后我们用我们准备好的编辑器打开我们创建的Shader文件。来看一下Unity Shader的结构。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517191548889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="ShaderStruct"></p>
<p>接下来，我们动手写一个最简单的Shader，先把Shader文件里原来的内容<strong>全部删掉</strong>。</p>
<p>接着起个我们的名字(<strong>先按我的名字来</strong>，想秀的等看完教程╰(￣ω￣ｏ))。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shader&#x2F;C1&#x2F;1_SimpleShader&quot; &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后直接定义一个SubShader和Pass语义块(我们暂时不需要Properties块，因为我们暂时不需要在面板里输入任何变量)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">	Pass &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们开始CG代码片段的编写。先定义一个由CGPROGRAM和ENDCG所包围的片段(可以理解成前面都是在做设置，下面才是真正的Shader代码。CG意味着一种语法，它更像DX的HLSL Shader语法)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure>
<p>然后我们进行两个预处理指令，指定哪个函数是顶点着色器，哪个函数是片段着色器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma vertex vert &#x2F;&#x2F; 指定vert函数是顶点着色器</span><br><span class="line">#pragma fragment frag &#x2F;&#x2F; 指定frag函数是片段着色器</span><br></pre></td></tr></table></figure>
<p>然后我们定义顶点着色器函数。我们先让这个函数只做普通的MVP变换。(MVP变换是渲染管线很重要的一个概念，我会在最后给出一些阅读材料让读者去了解)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; float4是指一个4个分量的float类型</span><br><span class="line">&#x2F;&#x2F; 输入一个float4,这个参数来源于POSITION</span><br><span class="line">&#x2F;&#x2F; 输出一个float4,这个参数将会写到SV_POSITION</span><br><span class="line">float4 vert(float4 position:POSITION) : SV_POSITION &#123;</span><br><span class="line">	return UnityObjectToClipPos(position); &#x2F;&#x2F;MVP变换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到的POSITION和SV_POSITION大家可以理解为是一块存储空间，Unity会把这段存储空间里的值赋值给你的变量，或者把你变量的值复制到对应存储空间中。其中顶点着色器必须输出SV_POSITION用于后续处理，片段着色器也必须输出SV_Target来指定一个片段颜色。</p>
<p>然后我们定义一个不管怎样都输出红色的片段着色器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; fixed比float的精度要小，会更省内存。一般(-2,2)范围的浮点数可以用fixed。</span><br><span class="line">&#x2F;&#x2F; 输出一个fixed4，写到SV_Target里</span><br><span class="line">fixed4 frag() : SV_Target &#123;</span><br><span class="line">    &#x2F;&#x2F; 浅绿色，为什么要这种颜色。别问，我朋友说他喜欢绿。</span><br><span class="line">	return fixed4(0.2, 1.0, 0.5, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在我们一个最最最简单的UnityShader已经写完了。我们创建一个Material(右键-&gt;Create-&gt;Material), 然后在这个材质(Material)的控制面板里选择我们的Shader。(Unity Shader-&gt;C1-&gt;1_Sample), 我们可以看到这个路径就是我们上面的Shader名字。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517155937644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="SelectShader"></p>
<p>然后我们在场景里创建一个球体，记得<strong>先reset</strong>一下。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517192125452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="resetSphere"></p>
<p>把材质拖到球体上，我们就可以看到一个浅绿色的球体了。</p>
<p><img src="https://img-blog.csdnimg.cn/2020051716001263.png#pic_center" alt="GreenSphere"></p>
<p>会不会发现有点成就感，但又没意思(这垃圾效果，不写也罢╰（‵□′）╯)。别急，毕竟我们还在入门嘛，都还没盖棺。</p>
<p>接下来我们用一下Properties，起码可以让我们指定颜色。在SubShader语义块前面加回我们的属性块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">	_MainColor (&quot;main color&quot;, COLOR) &#x3D; (0.2, 1.0, 0.5, 1.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>_MainColor 是我们后面代码里面要用的变量名</li>
<li>“main color” 是Unity控制面板中能看到的名字</li>
<li>COLOR 是这个属性的类型，COLOR是一个Float4</li>
<li>= 后面接的是默认值，用户不选的话，默认就是绿色。没错，那种绿色</li>
</ul>
<p>你会发现这时候，那个材质的控制面板已经允许我们选颜色了，但只是选了没用而已，接着我们就把这个颜色用上去。</p>
<p>我们在预定义语句的后面加上我们的变量声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma vertex vert</span><br><span class="line">#pragma fragment frag</span><br><span class="line"></span><br><span class="line">fixed4 _MainColor;</span><br></pre></td></tr></table></figure>

<p>然后片段着色器里，我们直接输出我们这个颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag() : SV_Target &#123;</span><br><span class="line">	return _MainColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在可以在材质面板里选择颜色来控制我们球体的颜色了。大家可以去选一下看看效果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517192030502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="pickcolor"></p>
<p>我选了一个我朋友更喜欢的深绿色。</p>
<p>当然，顶点着色器是可以给片段着色器传递参数的。<br>我们先在<strong>顶点着色器函数前</strong>定义一个结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123; &#x2F;&#x2F; vertex to fragment, 顶点着色器输出到片段着色器</span><br><span class="line">	float4 position : SV_POSITION;</span><br><span class="line">	float3 worldPos : TEXCOORD0; &#x2F;&#x2F; 世界空间下的顶点坐标 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们修改顶点着色器的输出为v2f，并且为每一个分量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(float4 position:POSITION) &#123;</span><br><span class="line">	v2f output;  &#x2F;&#x2F; 声明一个v2f变量</span><br><span class="line">	output.position &#x3D; UnityObjectToClipPos(position);</span><br><span class="line">	&#x2F;&#x2F; 用位置右乘一个model矩阵转换到世界空间</span><br><span class="line">	output.worldPos &#x3D; mul(unity_ObjectToWorld, position).xyz;</span><br><span class="line">	return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着只要把片段着色器的输入定义为v2f变量，我们就可以用上顶点着色器输出的值了(当然是经过插值的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 把世界空间的位置当成颜色输出，这也是Shader的一种Debug方法</span><br><span class="line">fixed4 frag(v2f input) : SV_Target &#123;</span><br><span class="line">	return fixed4(input.worldPos, 1.0) * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到现在的效果是，我们得到了一个五彩斑斓的球。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517160209175.png#pic_center" alt="ColorSphere"></p>
<p>如果出现问题的，可以到GitHub上<a href="https://github.com/gjbian/Unity-Shader-Study/blob/master/Assets/Shaders/1_SampleShader.shader" target="_blank" rel="noopener">查看源码。</a></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这里我就结束了我的第一篇入门分享，之后的节奏大概是每周一更，也有可能多更，但尽量不停更 - -。大家有疑问的也欢迎评论怼我，我会尽量认真看，我写错的地方也会去纠正。</p>
<p>另外，我一直相信，只要人人都付出一点爱，我就会O(∩_∩)O嘿嘿嘿。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517160234929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhMTA0MTMzNTg1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="vxpay"></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>MVP变换：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/</a></p>
<p>github地址：<a href="https://github.com/gjbian/Unity-Shader-Study" target="_blank" rel="noopener">https://github.com/gjbian/Unity-Shader-Study</a></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/GodBian/2020/06/01/UnityShader 从入门到盖棺(三)/">UnityShader 从入门到盖棺(三)</a>
      </li>
    
      <li>
        <a href="/GodBian/2020/05/24/UnityShader 从入门到盖棺(二)/">UnityShader 从入门到盖棺(二)</a>
      </li>
    
      <li>
        <a href="/GodBian/2020/05/17/UnityShader 从入门到盖棺(一)/">UnityShader 从入门到盖棺(一)</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 John Doe
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



</body>
</html>

